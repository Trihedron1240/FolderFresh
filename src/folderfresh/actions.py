
from pathlib import Path
import os
import shutil
import time
import json
from datetime import datetime
from .config import save_config
from .utils import (
    scan_dir,
    file_is_old_enough,
    remove_empty_category_folders,
    group_duplicates
)
from .sorting import pick_category, pick_smart_category
from .sorting import plan_moves
from .constants import LOG_FILENAME
from .naming import resolve_category
def save_log(root: Path, moves: list[dict], mode: str) -> Path:
    log_path = root / LOG_FILENAME
    payload = {
        "when": datetime.now().isoformat(timespec="seconds"),
        "mode": mode,  # "move" or "copy"
        "moves": moves,
    }
    with open(log_path, "w", encoding="utf-8") as f:
        json.dump(payload, f, indent=2)
    return log_path


def load_log(root: Path) -> dict | None:
    log_path = root / LOG_FILENAME
    if not log_path.exists():
        return None
    try:
        with open(log_path, "r", encoding="utf-8") as f:
            return json.load(f)
    except Exception:
        return None
    
# ========== PREVIEW ==========================================================

def do_preview(app):
    """
    Backend logic for the Preview button.
    Returns the planned moves list.
    """
    folder = app.selected_folder
    if not folder or not folder.exists():
        return []

    # Respect Desktop special rule
    desktop = Path(os.path.join(os.path.expanduser("~"), "Desktop"))
    include_sub = False if folder == desktop else bool(app.include_sub.get())

    min_days = int(app.age_filter_entry.get() or 0)

    ignore_raw = app.config_data.get("ignore_exts", "")
    ignore_set = {ext.strip().lower() for ext in ignore_raw.split(";") if ext.strip()}

    last_mode = app.config_data.get("last_sort_mode", None)
    current_mode = "smart" if app.smart_mode.get() else "simple"
    skip_categories = (last_mode == current_mode)

    files_all = scan_dir(
        folder,
        include_sub,
        app.skip_hidden.get(),
        ignore_set,
        skip_categories
    )

    files = [
        f for f in files_all
        if file_is_old_enough(f, min_days)
        and f.suffix.lower() not in ignore_set
    ]

    moves = []
    use_smart = app.smart_mode.get()

    for p in files:
        folder_name = pick_smart_category(p) if use_smart else None
        if not folder_name:
            folder_name = pick_category(p.suffix)

        folder_name = resolve_category(folder_name, app.config_data)


        dst = folder / folder_name / p.name

        if p != dst:
            moves.append({"src": str(p), "dst": str(dst)})

    return moves


# ========== ORGANISE =========================================================

def do_organise(app, moves):
    """
    Executes the moves generated by preview or fresh planning.
    Returns list of moves_done (including errors).
    """
    folder = app.selected_folder
    min_days = int(app.age_filter_entry.get() or 0)

    moves_done = []


    for m in moves:
        src = m["src"]

        # --- GET ORIGINAL DST ---
        dst = Path(m["dst"])

        # --- EXTRACT DEFAULT CATEGORY NAME ---
        default_cat = dst.parent.name

        # --- APPLY USER-DEFINED CATEGORY NAME ---
        new_cat = resolve_category(default_cat, app.config_data)

        # --- REBUILD DESTINATION WITH UPDATED CATEGORY NAME ---
        new_dst = Path(app.selected_folder) / new_cat / dst.name
        m["dst"] = str(new_dst)   # update for logging/undo

        try:
            new_dst.parent.mkdir(parents=True, exist_ok=True)

            if app.safe_mode.get():
                shutil.copy2(src, new_dst)
            else:
                shutil.move(src, new_dst)

            moves_done.append(m)

        except Exception as e:
            moves_done.append({"src": src, "dst": str(new_dst), "error": str(e)})

    # Log only moves (not copy)
    from .utils import save_log  # local import avoids circular issues

    mode = "copy" if app.safe_mode.get() else "move"
    save_log(Path(folder), moves_done, mode)

    # Save mode for next preview
    app.config_data["last_sort_mode"] = "smart" if app.smart_mode.get() else "simple"
    save_config(app.config_data)

    # Remove empty folders
    remove_empty_category_folders(folder)

    return moves_done


# ========== UNDO =============================================================

def do_undo(app):
    """
    Undo last move session.
    """
    folder = app.selected_folder
    log_path = folder / LOG_FILENAME

    if not log_path.exists():
        return None

    import json
    data = json.load(open(log_path, "r", encoding="utf-8"))

    if data.get("mode") == "copy":
        return "copy_mode"

    moves = data.get("moves", [])
    success = 0

    for m in reversed(moves):
        src = Path(m["src"])
        dst = Path(m["dst"])
        try:
            if dst.exists():
                src.parent.mkdir(parents=True, exist_ok=True)
                shutil.move(str(dst), str(src))
                success += 1
        except:
            pass

    try:
        log_path.unlink(missing_ok=True)
    except:
        pass

    remove_empty_category_folders(folder)
    # Reset last sort mode after undo so next sort scans fully
    app.config_data["last_sort_mode"] = None
    save_config(app.config_data)
    return success


# ========== DUPLICATES =======================================================

def do_find_duplicates(app):
    folder = app.selected_folder

    ignore_raw = app.config_data.get("ignore_exts", "")
    ignore_set = {ext.strip().lower() for ext in ignore_raw.split(";") if ext.strip()}

    last_mode = app.config_data.get("last_sort_mode", None)
    current_mode = "smart" if app.smart_mode.get() else "simple"
    skip_categories = False

    files_all = scan_dir(
        folder,
        app.include_sub.get(),
        app.skip_hidden.get(),
        ignore_set,
        skip_categories
    )

    files = [f for f in files_all if f.suffix.lower() not in ignore_set]

    groups = group_duplicates(files)
    return groups
